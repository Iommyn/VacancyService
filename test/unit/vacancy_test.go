// Code generated by MockGen. DO NOT EDIT.
// Source: C:\Users\iommy\Desktop\VacancyService\internal\usecases\interfaces.go

// Package mocks is a generated GoMock package.
package unit

import (
	entity "VacancyService/internal/entity"
	"VacancyService/test/mocks"
	context "context"
	reflect "reflect"
	"testing"

	gomock "github.com/golang/mock/gomock"
)

func TestNewMockVacancyService(t *testing.T) {
	type args struct {
		ctrl *gomock.Controller
	}
	tests := []struct {
		name string
		args args
		want *mocks.MockVacancyService
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := mocks.NewMockVacancyService(tt.args.ctrl); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("NewMockVacancyService() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestMockVacancyService_EXPECT(t *testing.T) {
	tests := []struct {
		name string
		m    *mocks.MockVacancyService
		want *mocks.MockVacancyServiceMockRecorder
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := tt.m.EXPECT(); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("MockVacancyService.EXPECT() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestMockVacancyService_CreateVacancy(t *testing.T) {
	type args struct {
		ctx     context.Context
		vacancy *entity.Vacancy
	}
	tests := []struct {
		name    string
		m       *mocks.MockVacancyService
		args    args
		wantErr bool
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if err := tt.m.CreateVacancy(tt.args.ctx, tt.args.vacancy); (err != nil) != tt.wantErr {
				t.Errorf("MockVacancyService.CreateVacancy() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}

func TestMockVacancyServiceMockRecorder_CreateVacancy(t *testing.T) {
	type args struct {
		ctx     interface{}
		vacancy interface{}
	}
	tests := []struct {
		name string
		mr   *mocks.MockVacancyServiceMockRecorder
		args args
		want *gomock.Call
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := tt.mr.CreateVacancy(tt.args.ctx, tt.args.vacancy); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("MockVacancyServiceMockRecorder.CreateVacancy() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestMockVacancyService_DeleteVacancy(t *testing.T) {
	type args struct {
		ctx context.Context
		id  int64
	}
	tests := []struct {
		name    string
		m       *mocks.MockVacancyService
		args    args
		wantErr bool
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if err := tt.m.DeleteVacancy(tt.args.ctx, tt.args.id); (err != nil) != tt.wantErr {
				t.Errorf("MockVacancyService.DeleteVacancy() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}

func TestMockVacancyServiceMockRecorder_DeleteVacancy(t *testing.T) {
	type args struct {
		ctx interface{}
		id  interface{}
	}
	tests := []struct {
		name string
		mr   *mocks.MockVacancyServiceMockRecorder
		args args
		want *gomock.Call
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := tt.mr.DeleteVacancy(tt.args.ctx, tt.args.id); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("MockVacancyServiceMockRecorder.DeleteVacancy() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestMockVacancyService_GetAllVacancies(t *testing.T) {
	type args struct {
		ctx context.Context
	}
	tests := []struct {
		name    string
		m       *mocks.MockVacancyService
		args    args
		want    []*entity.Vacancy
		wantErr bool
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := tt.m.GetAllVacancies(tt.args.ctx)
			if (err != nil) != tt.wantErr {
				t.Errorf("MockVacancyService.GetAllVacancies() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("MockVacancyService.GetAllVacancies() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestMockVacancyServiceMockRecorder_GetAllVacancies(t *testing.T) {
	type args struct {
		ctx interface{}
	}
	tests := []struct {
		name string
		mr   *mocks.MockVacancyServiceMockRecorder
		args args
		want *gomock.Call
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := tt.mr.GetAllVacancies(tt.args.ctx); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("MockVacancyServiceMockRecorder.GetAllVacancies() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestMockVacancyService_GetVacancyByID(t *testing.T) {
	type args struct {
		ctx context.Context
		id  int64
	}
	tests := []struct {
		name    string
		m       *mocks.MockVacancyService
		args    args
		want    *entity.Vacancy
		wantErr bool
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := tt.m.GetVacancyByID(tt.args.ctx, tt.args.id)
			if (err != nil) != tt.wantErr {
				t.Errorf("MockVacancyService.GetVacancyByID() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("MockVacancyService.GetVacancyByID() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestMockVacancyServiceMockRecorder_GetVacancyByID(t *testing.T) {
	type args struct {
		ctx interface{}
		id  interface{}
	}
	tests := []struct {
		name string
		mr   *mocks.MockVacancyServiceMockRecorder
		args args
		want *gomock.Call
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := tt.mr.GetVacancyByID(tt.args.ctx, tt.args.id); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("MockVacancyServiceMockRecorder.GetVacancyByID() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestMockVacancyService_UpdateVacancy(t *testing.T) {
	type args struct {
		ctx     context.Context
		vacancy *entity.Vacancy
	}
	tests := []struct {
		name    string
		m       *mocks.MockVacancyService
		args    args
		wantErr bool
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if err := tt.m.UpdateVacancy(tt.args.ctx, tt.args.vacancy); (err != nil) != tt.wantErr {
				t.Errorf("MockVacancyService.UpdateVacancy() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}

func TestMockVacancyServiceMockRecorder_UpdateVacancy(t *testing.T) {
	type args struct {
		ctx     interface{}
		vacancy interface{}
	}
	tests := []struct {
		name string
		mr   *mocks.MockVacancyServiceMockRecorder
		args args
		want *gomock.Call
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := tt.mr.UpdateVacancy(tt.args.ctx, tt.args.vacancy); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("MockVacancyServiceMockRecorder.UpdateVacancy() = %v, want %v", got, tt.want)
			}
		})
	}
}
